//zhejing 2500
/*
有N个形状和大小相同但重量不同的珠子。N是一个奇数，珠子被标记为1, 2，……N。你的任
务是找到珠子的重量中位数（（（N + 1）/ 2）在所有珠子）。对一些珠子做了以下比较：
用一个刻度比较珠子的重量。我们可以确定哪一个比两个珠子之间的重。结果，我们现在知
道一些珠子比其他的更重。我们要去掉一些中等重量的珠子。
例如，下面的结果表明，m比较m和4＝5后，哪个珠子更重。

1。珠子2比珠子1重。

2。珠子4比珠子3重。

3.珠子5比珠子1重。

4。珠子4比珠子2重。
从上面的结果，虽然我们不能准确地确定哪一个是中位数珠，我们知道，珠1和珠4永远不会
有中位数重量：珠2, 4, 5重于珠1，珠1, 2, 3轻珠4。因此，我们可以去掉这两个珠子。
写一个程序来计算不可能有中等重量的珠子数量。
输入规格
输入文件的第一行包含一个整数t（1 < =t < = 11），测试用例的数量，接着是每个测试用例
的输入数据。每个测试用例的输入如下所示：

输入数据的第一行包含一个整数n（1 < = n＝99）表示珠子的数量，m表示珠子对的数量。
在每一个m线中，两个数被给定，其中第一个珠子比第二个珠子重。
输出规格
每个测试用例应该有一行。打印出从未有过中等重量的珠子数量。
样本输入


1

5 4

2 1

4 3

5 1

4 2


示例输出


2
*/
#include <stdio.h>
#include <string.h>
int map[100][100];
int main()
{
 int t,n,m,i,j,k,sum,a,b;
 scanf("%d",&t);
 while(t--)
 {
  sum=0;
  memset(map,0,sizeof(map));
  scanf("%d%d",&n,&m);
  for(i=0;i<m;i++)
  {
   scanf("%d%d",&a,&b);
   map[a-1][b-1]=1;//1代表a>b;
   map[b-1][a-1]=2;//2代表a<b;

//0代表a和b没有关系
  }
  for(k=0;k<n;k++)
   for(i=0;i<n;i++)
    for(j=0;j<n;j++)
     if(map[i][k]==map[k][j]&&map[i][k])
      map[i][j]=map[k][j];//eg:3>2>1
     int c[3]; // k i j
     for(i=0;i<n;i++) // 这一句目的就是把没有直接关系的a和b，赋给关系；
     {
      memset(c,0,sizeof(c));
      for(j=0;j<n;j++)
      {
       c[map[i][j]]++;//i遍历和每一个j的关系；
      }
      if(c[1]>n/2||c[2]>n/2)
       sum++;
     }
     printf("%d\n",sum);
 }
 return 0;
}
